;; Test suite for SRFI-125: Intermediate hash tables
;; 
;; Comprehensive tests for hash table operations, performance,
;; and integration with existing Lambdust functionality.

(import (scheme base)
        (srfi 125)
        (srfi 1))

;; ============= BASIC HASH TABLE OPERATIONS =============

;; Test hash table creation and predicates
(define test-hash-table-creation
  (lambda ()
    (display "Testing hash table creation and predicates...\n")
    
    ;; Test basic creation
    (define ht1 (make-hash-table))
    (assert (hash-table? ht1) "make-hash-table should create a hash table")
    (assert (hash-table-empty? ht1) "New hash table should be empty")
    (assert (= (hash-table-size ht1) 0) "Empty hash table size should be 0")
    (assert (hash-table-mutable? ht1) "Default hash table should be mutable")
    
    ;; Test creation with custom equality function
    (define ht2 (make-hash-table string=?))
    (assert (hash-table? ht2) "Hash table with custom equality should be a hash table")
    (assert (eq? (hash-table-equivalence-function ht2) string=?) "Should store custom equality function")
    
    ;; Test creation with custom hash function
    (define simple-hash (lambda (x) (modulo (string-length (symbol->string x)) 100)))
    (define ht3 (make-hash-table eq? simple-hash))
    (assert (hash-table? ht3) "Hash table with custom hash function")
    (assert (eq? (hash-table-hash-function ht3) simple-hash) "Should store custom hash function")
    
    ;; Test hash-table constructor
    (define ht4 (hash-table equal? default-hash-function 'a 1 'b 2 'c 3))
    (assert (hash-table? ht4) "hash-table constructor should work")
    (assert (= (hash-table-size ht4) 3) "hash-table constructor should add elements")
    (assert (= (hash-table-ref ht4 'a) 1) "hash-table constructor element access")
    
    ;; Test non-hash-tables
    (assert (not (hash-table? '())) "Empty list should not be a hash table")
    (assert (not (hash-table? #(1 2 3))) "Vector should not be a hash table")
    (assert (not (hash-table? 42)) "Number should not be a hash table")
    
    (display "Hash table creation tests passed!\n")))

;; Test basic hash table operations
(define test-basic-operations
  (lambda ()
    (display "Testing basic hash table operations...\n")
    
    (define ht (make-hash-table))
    
    ;; Test insertion and retrieval
    (hash-table-set! ht 'key1 'value1)
    (assert (= (hash-table-size ht) 1) "Size should be 1 after first insertion")
    (assert (not (hash-table-empty? ht)) "Hash table should not be empty")
    (assert (hash-table-contains? ht 'key1) "Should contain inserted key")
    (assert (eq? (hash-table-ref ht 'key1) 'value1) "Should retrieve correct value")
    
    ;; Test multiple insertions
    (hash-table-set! ht 'key2 'value2 'key3 'value3)
    (assert (= (hash-table-size ht) 3) "Size should be 3 after multiple insertions")
    (assert (hash-table-contains? ht 'key2) "Should contain key2")
    (assert (hash-table-contains? ht 'key3) "Should contain key3")
    (assert (eq? (hash-table-ref ht 'key2) 'value2) "Should retrieve key2 value")
    (assert (eq? (hash-table-ref ht 'key3) 'value3) "Should retrieve key3 value")
    
    ;; Test key overwriting
    (hash-table-set! ht 'key1 'new-value1)
    (assert (= (hash-table-size ht) 3) "Size should remain 3 after overwrite")
    (assert (eq? (hash-table-ref ht 'key1) 'new-value1) "Should retrieve updated value")
    
    ;; Test deletion
    (define deleted-count (hash-table-delete! ht 'key2))
    (assert (= deleted-count 1) "Should return number of deleted keys")
    (assert (= (hash-table-size ht) 2) "Size should be 2 after deletion")
    (assert (not (hash-table-contains? ht 'key2)) "Should not contain deleted key")
    
    ;; Test multiple deletions
    (define deleted-count2 (hash-table-delete! ht 'key1 'key3 'nonexistent))
    (assert (= deleted-count2 2) "Should return 2 for two existing keys")
    (assert (= (hash-table-size ht) 0) "Should be empty after deleting remaining keys")
    (assert (hash-table-empty? ht) "Should be empty")
    
    (display "Basic operations tests passed!\n")))

;; Test hash table reference operations
(define test-reference-operations
  (lambda ()
    (display "Testing hash table reference operations...\n")
    
    (define ht (make-hash-table))
    (hash-table-set! ht 'a 1 'b 2 'c 3)
    
    ;; Test hash-table-ref with default
    (assert (= (hash-table-ref ht 'a 999) 1) "Should return actual value when key exists")
    (assert (= (hash-table-ref ht 'nonexistent 999) 999) "Should return default when key missing")
    
    ;; Test hash-table-ref/default
    (assert (= (hash-table-ref/default ht 'b 888) 2) "ref/default should work with existing key")
    (assert (= (hash-table-ref/default ht 'missing 888) 888) "ref/default should work with missing key")
    
    ;; Test hash-table-ref with failure thunk
    (assert (= (hash-table-ref ht 'c 0 (lambda () 777)) 3) "Should return value when key exists")
    (assert (= (hash-table-ref ht 'missing 0 (lambda () 777)) 777) "Should call failure thunk")
    
    ;; Test hash-table-ref without default (should error for missing key)
    (define (test-missing-key-error)
      (guard (condition (else #t))
        (hash-table-ref ht 'definitely-missing)
        #f))
    (assert (test-missing-key-error) "Should error when key missing and no default")
    
    (display "Reference operations tests passed!\n")))

;; ============= ADVANCED HASH TABLE OPERATIONS =============

;; Test hash table update operations
(define test-update-operations
  (lambda ()
    (display "Testing hash table update operations...\n")
    
    (define ht (make-hash-table))
    (hash-table-set! ht 'counter 0 'list '() 'string "hello")
    
    ;; Test hash-table-update!
    (hash-table-update! ht 'counter (lambda (x) (+ x 1)))
    (assert (= (hash-table-ref ht 'counter) 1) "Counter should be incremented")
    
    (hash-table-update! ht 'list (lambda (lst) (cons 'new lst)))
    (assert (equal? (hash-table-ref ht 'list) '(new)) "List should be updated")
    
    ;; Test hash-table-update!/default
    (hash-table-update!/default ht 'new-counter (lambda (x) (+ x 1)) 10)
    (assert (= (hash-table-ref ht 'new-counter) 11) "Should use default and apply function")
    
    (hash-table-update!/default ht 'counter (lambda (x) (* x 2)) 0)
    (assert (= (hash-table-ref ht 'counter) 2) "Should use existing value, not default")
    
    ;; Test hash-table-intern!
    (define value1 (hash-table-intern! ht 'existing 999))
    (assert (equal? (hash-table-ref ht 'existing) value1) "intern! should return stored value")
    
    (define value2 (hash-table-intern! ht 'brand-new 777))
    (assert (= value2 777) "intern! should return new value")
    (assert (= (hash-table-ref ht 'brand-new) 777) "intern! should store new value")
    
    ;; Test hash-table-intern! with thunk
    (define value3 (hash-table-intern! ht 'computed (lambda () (* 6 7))))
    (assert (= value3 42) "intern! with thunk should compute value")
    (assert (= (hash-table-ref ht 'computed) 42) "intern! should store computed value")
    
    ;; Test hash-table-pop!
    (define old-counter (hash-table-pop! ht 'counter))
    (assert (= old-counter 2) "pop! should return old value")
    (assert (not (hash-table-contains? ht 'counter)) "pop! should remove key")
    
    (define popped-missing (hash-table-pop! ht 'missing 'default-value))
    (assert (eq? popped-missing 'default-value) "pop! should return default for missing key")
    
    (display "Update operations tests passed!\n")))

;; Test hash table bulk operations
(define test-bulk-operations
  (lambda ()
    (display "Testing hash table bulk operations...\n")
    
    (define ht (make-hash-table))
    (hash-table-set! ht 'a 1 'b 2 'c 3 'd 4 'e 5)
    
    ;; Test hash-table-keys
    (define keys (hash-table-keys ht))
    (assert (= (length keys) 5) "Should have 5 keys")
    (assert (every (lambda (k) (hash-table-contains? ht k)) keys) "All returned keys should exist")
    
    ;; Test hash-table-values
    (define values (hash-table-values ht))
    (assert (= (length values) 5) "Should have 5 values")
    (assert (every number? values) "All values should be numbers")
    
    ;; Test hash-table-entries
    (define entries (hash-table-entries ht))
    (assert (= (length entries) 5) "Should have 5 entries")
    (assert (every pair? entries) "All entries should be pairs")
    
    ;; Test hash-table-find
    (define-values (found-key found-value)
      (hash-table-find ht (lambda (k v) (> v 3))))
    (assert found-key "Should find a key with value > 3")
    (assert (> found-value 3) "Found value should be > 3")
    (assert (= (hash-table-ref ht found-key) found-value) "Found key/value should match")
    
    ;; Test hash-table-find with no match
    (define-values (not-found-key not-found-value)
      (hash-table-find ht (lambda (k v) (> v 10))))
    (assert (not not-found-key) "Should not find key with value > 10")
    (assert (not not-found-value) "Should not find value > 10")
    
    ;; Test hash-table-count
    (define even-count (hash-table-count ht (lambda (k v) (even? v))))
    (assert (= even-count 2) "Should count 2 even values")
    
    (define all-count (hash-table-count ht (lambda (k v) #t)))
    (assert (= all-count 5) "Should count all 5 entries")
    
    (display "Bulk operations tests passed!\n")))

;; ============= HASH TABLE MAPPING AND FOLDING =============

;; Test mapping operations
(define test-mapping-operations
  (lambda ()
    (display "Testing hash table mapping operations...\n")
    
    (define ht (make-hash-table))
    (hash-table-set! ht 'a 1 'b 2 'c 3)
    
    ;; Test hash-table-map
    (define doubled-ht (hash-table-map (lambda (k v) (values k (* v 2)))
                                      equal? default-hash-function ht))
    (assert (hash-table? doubled-ht) "map should return hash table")
    (assert (= (hash-table-size doubled-ht) 3) "mapped table should have same size")
    (assert (= (hash-table-ref doubled-ht 'a) 2) "mapped values should be doubled")
    (assert (= (hash-table-ref doubled-ht 'c) 6) "all mapped values should be doubled")
    
    ;; Test hash-table-for-each with side effects
    (define side-effects '())
    (hash-table-for-each (lambda (k v)
                          (set! side-effects (cons (cons k v) side-effects)))
                        ht)
    (assert (= (length side-effects) 3) "for-each should visit all entries")
    (assert (every pair? side-effects) "for-each should provide key-value pairs")
    
    ;; Test hash-table-map->list
    (define key-value-list (hash-table-map->list (lambda (k v) (list k v)) ht))
    (assert (= (length key-value-list) 3) "map->list should return list of results")
    (assert (every list? key-value-list) "map->list results should be lists")
    
    ;; Test hash-table-fold
    (define sum (hash-table-fold (lambda (k v acc) (+ v acc)) 0 ht))
    (assert (= sum 6) "fold should sum all values")
    
    (define key-list (hash-table-fold (lambda (k v acc) (cons k acc)) '() ht))
    (assert (= (length key-list) 3) "fold can build list of keys")
    
    ;; Test hash-table-prune!
    (hash-table-prune! (lambda (k v) (odd? v)) ht)
    (assert (= (hash-table-size ht) 1) "prune! should remove odd values")
    (assert (hash-table-contains? ht 'b) "even value should remain")
    (assert (not (hash-table-contains? ht 'a)) "odd values should be removed")
    (assert (not (hash-table-contains? ht 'c)) "all odd values should be removed")
    
    (display "Mapping operations tests passed!\n")))

;; ============= HASH TABLE CONVERSION AND COPYING =============

;; Test conversion operations
(define test-conversion-operations
  (lambda ()
    (display "Testing hash table conversion operations...\n")
    
    ;; Test alist->hash-table
    (define test-alist '((a . 1) (b . 2) (c . 3)))
    (define ht-from-alist (alist->hash-table test-alist))
    (assert (hash-table? ht-from-alist) "alist->hash-table should create hash table")
    (assert (= (hash-table-size ht-from-alist) 3) "should have all alist entries")
    (assert (= (hash-table-ref ht-from-alist 'a) 1) "should preserve alist values")
    
    ;; Test hash-table->alist
    (define alist-from-ht (hash-table->alist ht-from-alist))
    (assert (= (length alist-from-ht) 3) "->alist should have all entries")
    (assert (every pair? alist-from-ht) "->alist should return pairs")
    
    ;; Test round-trip conversion
    (define ht-roundtrip (alist->hash-table alist-from-ht))
    (assert (= (hash-table-size ht-roundtrip) 3) "round-trip should preserve size")
    (assert (= (hash-table-ref ht-roundtrip 'b) 2) "round-trip should preserve values")
    
    ;; Test hash-table-unfold
    (define unfolded-ht
      (hash-table-unfold (lambda (x) (> x 5))        ; stop?
                         (lambda (x) (values x (* x x))) ; mapper
                         (lambda (x) (+ x 1))         ; successor
                         1                            ; seed
                         equal? default-hash-function))
    (assert (hash-table? unfolded-ht) "unfold should create hash table")
    (assert (= (hash-table-ref unfolded-ht 1) 1) "unfold should map 1->1")
    (assert (= (hash-table-ref unfolded-ht 5) 25) "unfold should map 5->25")
    (assert (not (hash-table-contains? unfolded-ht 6)) "unfold should stop at condition")
    
    (display "Conversion operations tests passed!\n")))

;; Test copying operations
(define test-copying-operations
  (lambda ()
    (display "Testing hash table copying operations...\n")
    
    (define original (make-hash-table))
    (hash-table-set! original 'a 1 'b 2 'c 3)
    
    ;; Test mutable copy
    (define mutable-copy (hash-table-copy original #t))
    (assert (hash-table? mutable-copy) "copy should create hash table")
    (assert (hash-table-mutable? mutable-copy) "should be mutable when requested")
    (assert (= (hash-table-size mutable-copy) 3) "copy should have same size")
    (assert (= (hash-table-ref mutable-copy 'a) 1) "copy should have same values")
    
    ;; Modify copy (should not affect original)
    (hash-table-set! mutable-copy 'a 999)
    (assert (= (hash-table-ref original 'a) 1) "original should be unmodified")
    (assert (= (hash-table-ref mutable-copy 'a) 999) "copy should be modified")
    
    ;; Test immutable copy
    (define immutable-copy (hash-table-copy original #f))
    (assert (hash-table? immutable-copy) "immutable copy should be hash table")
    (assert (not (hash-table-mutable? immutable-copy)) "should not be mutable")
    
    ;; Test that immutable copy cannot be modified
    (define (test-immutable-modification)
      (guard (condition (else #t))
        (hash-table-set! immutable-copy 'x 999)
        #f))
    (assert (test-immutable-modification) "immutable copy should reject modifications")
    
    (display "Copying operations tests passed!\n")))

;; ============= HASH TABLE EQUALITY AND COMPARISON =============

;; Test equality operations
(define test-equality-operations
  (lambda ()
    (display "Testing hash table equality operations...\n")
    
    (define ht1 (make-hash-table))
    (define ht2 (make-hash-table))
    (define ht3 (make-hash-table))
    
    ;; Test empty hash tables
    (assert (hash-table=? equal? ht1 ht2) "empty hash tables should be equal")
    
    ;; Add same elements to two tables
    (hash-table-set! ht1 'a 1 'b 2 'c 3)
    (hash-table-set! ht2 'c 3 'b 2 'a 1)  ; different order
    
    (assert (hash-table=? equal? ht1 ht2) "tables with same elements should be equal")
    
    ;; Add different element to third table
    (hash-table-set! ht3 'a 1 'b 2 'c 999)
    
    (assert (not (hash-table=? equal? ht1 ht3)) "tables with different values should not be equal")
    
    ;; Test with different sizes
    (hash-table-set! ht3 'd 4)
    (hash-table-set! ht3 'c 3)  ; fix the value
    
    (assert (not (hash-table=? equal? ht1 ht3)) "tables with different sizes should not be equal")
    
    ;; Test multiple table comparison
    (define ht4 (hash-table-copy ht1))
    (assert (hash-table=? equal? ht1 ht2 ht4) "multiple equal tables")
    (assert (not (hash-table=? equal? ht1 ht2 ht3)) "multiple tables with one different")
    
    ;; Test with custom value equality
    (define string-ht1 (make-hash-table))
    (define string-ht2 (make-hash-table))
    (hash-table-set! string-ht1 'a "hello" 'b "world")
    (hash-table-set! string-ht2 'a "hello" 'b "world")
    
    (assert (hash-table=? string=? string-ht1 string-ht2) "string equality comparison")
    
    (hash-table-set! string-ht2 'b "WORLD")
    (assert (not (hash-table=? string=? string-ht1 string-ht2)) "case-sensitive string comparison")
    (assert (hash-table=? string-ci=? string-ht1 string-ht2) "case-insensitive string comparison")
    
    (display "Equality operations tests passed!\n")))

;; ============= HASH TABLE MERGE OPERATIONS =============

;; Test merge operations
(define test-merge-operations
  (lambda ()
    (display "Testing hash table merge operations...\n")
    
    (define ht1 (make-hash-table))
    (define ht2 (make-hash-table))
    (define ht3 (make-hash-table))
    
    (hash-table-set! ht1 'a 1 'b 2)
    (hash-table-set! ht2 'b 20 'c 3)
    (hash-table-set! ht3 'c 30 'd 4)
    
    ;; Test hash-table-union!
    (define union-result (hash-table-copy ht1))
    (hash-table-union! union-result ht2)
    
    (assert (= (hash-table-size union-result) 3) "union should have 3 elements")
    (assert (= (hash-table-ref union-result 'a) 1) "union should keep ht1 'a")
    (assert (= (hash-table-ref union-result 'b) 2) "union should prefer ht1 'b over ht2 'b")
    (assert (= (hash-table-ref union-result 'c) 3) "union should add ht2 'c")
    
    ;; Test hash-table-intersection!
    (hash-table-set! ht1 'c 100)  ; Add common key
    (define intersection-result (hash-table-copy ht1))
    (hash-table-intersection! intersection-result ht2)
    
    (assert (= (hash-table-size intersection-result) 2) "intersection should have 2 elements")
    (assert (hash-table-contains? intersection-result 'b) "intersection should contain 'b")
    (assert (hash-table-contains? intersection-result 'c) "intersection should contain 'c")
    (assert (not (hash-table-contains? intersection-result 'a)) "intersection should not contain 'a")
    
    ;; Test hash-table-difference!
    (define diff-ht1 (make-hash-table))
    (define diff-ht2 (make-hash-table))
    (hash-table-set! diff-ht1 'a 1 'b 2 'c 3 'd 4)
    (hash-table-set! diff-ht2 'b 20 'c 30)
    
    (hash-table-difference! diff-ht1 diff-ht2)
    
    (assert (= (hash-table-size diff-ht1) 2) "difference should have 2 elements")
    (assert (hash-table-contains? diff-ht1 'a) "difference should contain 'a")
    (assert (hash-table-contains? diff-ht1 'd) "difference should contain 'd")
    (assert (not (hash-table-contains? diff-ht1 'b)) "difference should not contain 'b")
    (assert (not (hash-table-contains? diff-ht1 'c)) "difference should not contain 'c")
    
    ;; Test hash-table-xor!
    (define xor-ht1 (make-hash-table))
    (define xor-ht2 (make-hash-table))
    (hash-table-set! xor-ht1 'a 1 'b 2 'c 3)
    (hash-table-set! xor-ht2 'c 30 'd 4 'e 5)
    
    (hash-table-xor! xor-ht1 xor-ht2)
    
    (assert (= (hash-table-size xor-ht1) 4) "xor should have 4 elements")
    (assert (hash-table-contains? xor-ht1 'a) "xor should contain 'a from ht1")
    (assert (hash-table-contains? xor-ht1 'b) "xor should contain 'b from ht1")
    (assert (hash-table-contains? xor-ht1 'd) "xor should contain 'd from ht2")
    (assert (hash-table-contains? xor-ht1 'e) "xor should contain 'e from ht2")
    (assert (not (hash-table-contains? xor-ht1 'c)) "xor should not contain 'c (in both)")
    
    (display "Merge operations tests passed!\n")))

;; ============= HASH FUNCTION TESTS =============

;; Test different hash functions and equality predicates
(define test-hash-functions
  (lambda ()
    (display "Testing hash functions and equality predicates...\n")
    
    ;; Test with string keys and string=?
    (define string-ht (make-hash-table string=? string-hash))
    (hash-table-set! string-ht "hello" 1 "world" 2)
    
    (assert (= (hash-table-ref string-ht "hello") 1) "string hash table lookup")
    (assert (hash-table-contains? string-ht "world") "string hash table contains")
    
    ;; Test case sensitivity
    (assert (not (hash-table-contains? string-ht "HELLO")) "string hash is case sensitive")
    
    ;; Test with numeric keys
    (define numeric-ht (make-hash-table = (lambda (n) (modulo n 100))))
    (hash-table-set! numeric-ht 1 'one 101 'one-oh-one 2 'two)
    
    (assert (eq? (hash-table-ref numeric-ht 1) 'one) "numeric hash table")
    (assert (eq? (hash-table-ref numeric-ht 101) 'one-oh-one) "hash collisions handled")
    
    ;; Test with symbol keys
    (define symbol-ht (make-hash-table eq?))
    (hash-table-set! symbol-ht 'foo 'bar 'baz 'qux)
    
    (assert (eq? (hash-table-ref symbol-ht 'foo) 'bar) "symbol keys work")
    (assert (eq? (hash-table-ref symbol-ht 'baz) 'qux) "multiple symbol keys")
    
    ;; Test with list keys (structural equality)
    (define list-ht (make-hash-table equal?))
    (hash-table-set! list-ht '(1 2 3) 'list1 '(a b) 'list2)
    
    (assert (eq? (hash-table-ref list-ht '(1 2 3)) 'list1) "list keys with equal?")
    (assert (eq? (hash-table-ref list-ht '(a b)) 'list2) "different list keys")
    
    (display "Hash function tests passed!\n")))

;; ============= ERROR HANDLING TESTS =============

;; Test error conditions
(define test-error-handling
  (lambda ()
    (display "Testing hash table error handling...\n")
    
    ;; Test operations on immutable hash tables
    (define immutable-ht (hash-table-copy (make-hash-table) #f))
    
    (define (test-immutable-set)
      (guard (condition (else #t))
        (hash-table-set! immutable-ht 'key 'value)
        #f))
    (assert (test-immutable-set) "set! on immutable hash table should error")
    
    (define (test-immutable-delete)
      (guard (condition (else #t))
        (hash-table-delete! immutable-ht 'key)
        #f))
    (assert (test-immutable-delete) "delete! on immutable hash table should error")
    
    (define (test-immutable-clear)
      (guard (condition (else #t))
        (hash-table-clear! immutable-ht)
        #f))
    (assert (test-immutable-clear) "clear! on immutable hash table should error")
    
    ;; Test invalid arguments to hash-table constructor
    (define (test-odd-args)
      (guard (condition (else #t))
        (hash-table equal? default-hash-function 'key)  ; missing value
        #f))
    (assert (test-odd-args) "hash-table with odd number of args should error")
    
    ;; Test operations on non-hash-tables
    (define (test-non-hash-table-ref)
      (guard (condition (else #t))
        (hash-table-ref '() 'key)
        #f))
    (assert (test-non-hash-table-ref) "hash-table-ref on non-hash-table should error")
    
    (display "Error handling tests passed!\n")))

;; ============= PERFORMANCE TESTS =============

;; Test performance characteristics
(define test-performance
  (lambda ()
    (display "Testing hash table performance...\n")
    
    ;; Test with many elements
    (define large-ht (make-hash-table))
    
    ;; Insert many elements
    (do ((i 0 (+ i 1)))
        ((= i 1000))
      (hash-table-set! large-ht i (* i i)))
    
    (assert (= (hash-table-size large-ht) 1000) "large hash table size")
    (assert (= (hash-table-ref large-ht 500) 250000) "large hash table lookup")
    
    ;; Test that operations remain efficient
    (assert (hash-table-contains? large-ht 999) "contains check on large table")
    (assert (not (hash-table-contains? large-ht 1000)) "negative contains check")
    
    ;; Test bulk operations on large table
    (define keys (hash-table-keys large-ht))
    (assert (= (length keys) 1000) "keys operation on large table")
    
    ;; Test hash table resizing behavior
    (define resize-ht (make-hash-table))
    (do ((i 0 (+ i 1)))
        ((= i 100))
      (hash-table-set! resize-ht (string->symbol (number->string i)) i))
    
    (assert (= (hash-table-size resize-ht) 100) "resize test size")
    (assert (= (hash-table-ref resize-ht '50) 50) "resize test lookup")
    
    ;; Test with high collision rate
    (define collision-ht (make-hash-table = (lambda (x) 42)))  ; All keys hash to same value
    (do ((i 0 (+ i 1)))
        ((= i 50))
      (hash-table-set! collision-ht i i))
    
    (assert (= (hash-table-size collision-ht) 50) "high collision size")
    (assert (= (hash-table-ref collision-ht 25) 25) "high collision lookup")
    
    (display "Performance tests passed!\n")))

;; ============= INTEGRATION TESTS =============

;; Test integration with other data structures
(define test-integration
  (lambda ()
    (display "Testing integration with other data structures...\n")
    
    ;; Test hash table containing various data types
    (define mixed-ht (make-hash-table))
    (hash-table-set! mixed-ht 'number 42)
    (hash-table-set! mixed-ht 'string "hello")
    (hash-table-set! mixed-ht 'list '(1 2 3))
    (hash-table-set! mixed-ht 'vector #(a b c))
    (hash-table-set! mixed-ht 'nested-ht (make-hash-table))
    
    (assert (number? (hash-table-ref mixed-ht 'number)) "number stored correctly")
    (assert (string? (hash-table-ref mixed-ht 'string)) "string stored correctly")
    (assert (list? (hash-table-ref mixed-ht 'list)) "list stored correctly")
    (assert (vector? (hash-table-ref mixed-ht 'vector)) "vector stored correctly")
    (assert (hash-table? (hash-table-ref mixed-ht 'nested-ht)) "nested hash table stored correctly")
    
    ;; Test using hash table with SRFI-1 operations
    (define number-ht (make-hash-table))
    (for-each (lambda (n) (hash-table-set! number-ht n (* n n))) (iota 10 1))
    
    (define keys (hash-table-keys number-ht))
    (define filtered-keys (filter (lambda (k) (> k 5)) keys))
    (assert (every (lambda (k) (hash-table-contains? number-ht k)) filtered-keys)
            "SRFI-1 filter with hash table keys")
    
    ;; Test hash table as a cache
    (define (make-cached-function f)
      (let ((cache (make-hash-table)))
        (lambda (x)
          (hash-table-intern! cache x (lambda () (f x))))))
    
    (define call-count 0)
    (define expensive-func (lambda (x) (set! call-count (+ call-count 1)) (* x x)))
    (define cached-func (make-cached-function expensive-func))
    
    (assert (= (cached-func 5) 25) "cached function works")
    (assert (= call-count 1) "function called once")
    
    (assert (= (cached-func 5) 25) "cached function returns cached result")
    (assert (= call-count 1) "function not called again (cached)")
    
    (assert (= (cached-func 7) 49) "cached function works for new input")
    (assert (= call-count 2) "function called for new input")
    
    (display "Integration tests passed!\n")))

;; ============= TEST RUNNER =============

;; Simple assertion function
(define (assert condition message)
  (unless condition
    (error "Assertion failed:" message)))

;; Main test runner
(define (run-all-tests)
  (display "Starting SRFI-125 (Hash Tables) test suite...\n\n")
  
  (test-hash-table-creation)
  (test-basic-operations)
  (test-reference-operations)
  (test-update-operations)
  (test-bulk-operations)
  (test-mapping-operations)
  (test-conversion-operations)
  (test-copying-operations)
  (test-equality-operations)
  (test-merge-operations)
  (test-hash-functions)
  (test-error-handling)
  (test-performance)
  (test-integration)
  
  (display "\n=== All SRFI-125 tests passed! ===\n"))

;; Run the tests
(run-all-tests)