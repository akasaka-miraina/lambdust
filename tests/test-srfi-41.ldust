;; Test suite for SRFI-41: Streams
;; 
;; Comprehensive tests for stream operations, lazy evaluation,
;; and integration with existing Lambdust functionality.

(import (scheme base)
        (srfi 41)
        (srfi 1))

;; ============= BASIC STREAM OPERATIONS =============

;; Test stream type predicates
(define test-stream-predicates
  (lambda ()
    (display "Testing stream predicates...\n")
    
    ;; Test empty stream
    (assert (stream? stream-null) "stream-null should be a stream")
    (assert (stream-null? stream-null) "stream-null should be null")
    (assert (not (stream-pair? stream-null)) "stream-null should not be a pair")
    
    ;; Test non-empty stream
    (define test-stream (stream-cons 1 stream-null))
    (assert (stream? test-stream) "stream-cons result should be a stream")
    (assert (not (stream-null? test-stream)) "non-empty stream should not be null")
    (assert (stream-pair? test-stream) "non-empty stream should be a pair")
    
    ;; Test non-streams
    (assert (not (stream? '())) "empty list should not be a stream")
    (assert (not (stream? '(1 2 3))) "regular list should not be a stream")
    (assert (not (stream? 42)) "number should not be a stream")
    
    (display "Stream predicates tests passed!\n")))

;; Test stream car and cdr
(define test-stream-car-cdr
  (lambda ()
    (display "Testing stream-car and stream-cdr...\n")
    
    (define test-stream (stream-cons 1 (stream-cons 2 (stream-cons 3 stream-null))))
    
    ;; Test stream-car
    (assert (= (stream-car test-stream) 1) "stream-car should return first element")
    (assert (= (stream-car (stream-cdr test-stream)) 2) "stream-car of cdr should return second element")
    
    ;; Test stream-cdr
    (define rest (stream-cdr test-stream))
    (assert (stream? rest) "stream-cdr should return a stream")
    (assert (= (stream-car rest) 2) "first element of rest should be 2")
    
    ;; Test nested cdr
    (assert (= (stream-car (stream-cdr (stream-cdr test-stream))) 3) "nested cdr access")
    (assert (stream-null? (stream-cdr (stream-cdr (stream-cdr test-stream)))) "end should be null")
    
    (display "Stream car/cdr tests passed!\n")))

;; Test lazy evaluation
(define test-lazy-evaluation
  (lambda ()
    (display "Testing lazy evaluation...\n")
    
    (define side-effect-counter 0)
    
    (define (side-effect-proc x)
      (set! side-effect-counter (+ side-effect-counter 1))
      (* x 2))
    
    ;; Create stream with side effects
    (define lazy-stream
      (stream-cons 1
        (stream-cons (side-effect-proc 2)
          (stream-cons (side-effect-proc 3) stream-null))))
    
    ;; Side effects shouldn't happen yet
    (assert (= side-effect-counter 0) "Side effects should not occur during stream creation")
    
    ;; Access first element (no side effects in tail yet)
    (define first (stream-car lazy-stream))
    (assert (= first 1) "First element should be 1")
    (assert (= side-effect-counter 0) "Still no side effects")
    
    ;; Access second element (triggers first side effect)
    (define second (stream-car (stream-cdr lazy-stream)))
    (assert (= second 4) "Second element should be 4")
    (assert (= side-effect-counter 1) "First side effect should have occurred")
    
    ;; Access third element (triggers second side effect)
    (define third (stream-car (stream-cdr (stream-cdr lazy-stream))))
    (assert (= third 6) "Third element should be 6")
    (assert (= side-effect-counter 2) "Second side effect should have occurred")
    
    ;; Access elements again (no additional side effects due to memoization)
    (define second-again (stream-car (stream-cdr lazy-stream)))
    (assert (= second-again 4) "Memoized second element")
    (assert (= side-effect-counter 2) "No additional side effects")
    
    (display "Lazy evaluation tests passed!\n")))

;; ============= STREAM LIBRARY FUNCTIONS =============

;; Test list conversion
(define test-list-conversion
  (lambda ()
    (display "Testing list/stream conversion...\n")
    
    ;; list->stream
    (define test-list '(1 2 3 4 5))
    (define test-stream (list->stream test-list))
    
    (assert (stream? test-stream) "list->stream should return a stream")
    (assert (= (stream-car test-stream) 1) "First element should be 1")
    (assert (= (stream-car (stream-cdr test-stream)) 2) "Second element should be 2")
    
    ;; stream->list (finite)
    (define converted-list (stream->list test-stream))
    (assert (equal? converted-list test-list) "stream->list should preserve elements")
    
    ;; stream->list with limit
    (define partial-list (stream->list test-stream 3))
    (assert (equal? partial-list '(1 2 3)) "stream->list with limit")
    
    ;; Empty list/stream
    (define empty-stream (list->stream '()))
    (assert (stream-null? empty-stream) "Empty list should produce empty stream")
    (assert (equal? (stream->list empty-stream) '()) "Empty stream should produce empty list")
    
    (display "List conversion tests passed!\n")))

;; Test stream arithmetic
(define test-stream-arithmetic
  (lambda ()
    (display "Testing stream arithmetic functions...\n")
    
    ;; stream-from
    (define nats (stream-from 0))
    (assert (= (stream-ref nats 0) 0) "Natural numbers start at 0")
    (assert (= (stream-ref nats 1) 1) "Second natural number is 1")
    (assert (= (stream-ref nats 10) 10) "10th natural number is 10")
    
    ;; stream-from with step
    (define evens (stream-from 0 2))
    (assert (= (stream-ref evens 0) 0) "Even numbers start at 0")
    (assert (= (stream-ref evens 1) 2) "Second even number is 2")
    (assert (= (stream-ref evens 5) 10) "6th even number is 10")
    
    ;; stream-range
    (define range-5 (stream-range 0 5))
    (define range-list (stream->list range-5))
    (assert (equal? range-list '(0 1 2 3 4)) "Range 0 to 5")
    
    ;; stream-range with step
    (define range-step (stream-range 1 10 3))
    (define range-step-list (stream->list range-step))
    (assert (equal? range-step-list '(1 4 7)) "Range 1 to 10 step 3")
    
    (display "Stream arithmetic tests passed!\n")))

;; Test stream operations
(define test-stream-operations
  (lambda ()
    (display "Testing stream operations...\n")
    
    (define test-stream (list->stream '(1 2 3 4 5 6 7 8 9 10)))
    
    ;; stream-take
    (define first-3 (stream-take 3 test-stream))
    (assert (equal? (stream->list first-3) '(1 2 3)) "stream-take 3")
    
    ;; stream-drop
    (define drop-3 (stream-drop 3 test-stream))
    (assert (= (stream-car drop-3) 4) "stream-drop 3 should start at 4")
    
    ;; stream-filter
    (define evens (stream-filter even? test-stream))
    (assert (equal? (stream->list evens) '(2 4 6 8 10)) "Filter even numbers")
    
    ;; stream-map
    (define doubled (stream-map (lambda (x) (* x 2)) test-stream))
    (assert (equal? (stream->list doubled) '(2 4 6 8 10 12 14 16 18 20)) "Map double")
    
    ;; stream-append
    (define first-half (list->stream '(1 2 3))
    (define second-half (list->stream '(4 5 6))
    (define appended (stream-append first-half second-half))
    (assert (equal? (stream->list appended) '(1 2 3 4 5 6)) "Stream append")
    
    ;; stream-length (finite streams only)
    (assert (= (stream-length first-3) 3) "Length of first-3 should be 3")
    (assert (= (stream-length (list->stream '())) 0) "Length of empty stream should be 0")
    
    (display "Stream operations tests passed!\n")))

;; Test infinite streams
(define test-infinite-streams
  (lambda ()
    (display "Testing infinite streams...\n")
    
    ;; stream-constant
    (define ones (stream-constant 1))
    (assert (= (stream-ref ones 0) 1) "First constant")
    (assert (= (stream-ref ones 100) 1) "100th constant")
    (assert (= (stream-ref ones 1000) 1) "1000th constant")
    
    ;; stream-iterate
    (define powers-of-2 (stream-iterate (lambda (x) (* x 2)) 1))
    (assert (= (stream-ref powers-of-2 0) 1) "2^0 = 1")
    (assert (= (stream-ref powers-of-2 1) 2) "2^1 = 2")
    (assert (= (stream-ref powers-of-2 10) 1024) "2^10 = 1024")
    
    ;; Fibonacci using stream operations
    (define fibs
      (stream-cons 0
        (stream-cons 1
          (stream-map + fibs (stream-cdr fibs)))))
    
    (assert (= (stream-ref fibs 0) 0) "fib(0) = 0")
    (assert (= (stream-ref fibs 1) 1) "fib(1) = 1")
    (assert (= (stream-ref fibs 2) 1) "fib(2) = 1")
    (assert (= (stream-ref fibs 3) 2) "fib(3) = 2")
    (assert (= (stream-ref fibs 4) 3) "fib(4) = 3")
    (assert (= (stream-ref fibs 10) 55) "fib(10) = 55")
    
    (display "Infinite streams tests passed!\n")))

;; Test stream folding and aggregation
(define test-stream-folding
  (lambda ()
    (display "Testing stream folding and aggregation...\n")
    
    (define test-stream (list->stream '(1 2 3 4 5)))
    
    ;; stream-fold
    (define sum (stream-fold + 0 test-stream))
    (assert (= sum 15) "Sum should be 15")
    
    (define product (stream-fold * 1 test-stream))
    (assert (= product 120) "Product should be 120")
    
    ;; stream-scan (partial results)
    (define partial-sums (stream-scan + 0 test-stream))
    (define scan-list (stream->list partial-sums))
    (assert (equal? scan-list '(0 1 3 6 10 15)) "Partial sums")
    
    ;; stream-for-each (side effects)
    (define side-effect-list '())
    (stream-for-each (lambda (x) (set! side-effect-list (cons x side-effect-list)))
                     test-stream)
    (assert (equal? (reverse side-effect-list) '(1 2 3 4 5)) "for-each side effects")
    
    (display "Stream folding tests passed!\n")))

;; Test stream predicates and searching
(define test-stream-searching
  (lambda ()
    (display "Testing stream searching...\n")
    
    (define test-stream (list->stream '(1 2 3 4 5 6 7 8 9 10)))
    
    ;; stream-take-while
    (define less-than-5 (stream-take-while (lambda (x) (< x 5)) test-stream))
    (assert (equal? (stream->list less-than-5) '(1 2 3 4)) "Take while < 5")
    
    ;; stream-drop-while
    (define from-5 (stream-drop-while (lambda (x) (< x 5)) test-stream))
    (assert (= (stream-car from-5) 5) "Drop while < 5 should start at 5")
    
    ;; stream-ref with bounds
    (assert (= (stream-ref test-stream 0) 1) "stream-ref 0")
    (assert (= (stream-ref test-stream 9) 10) "stream-ref 9")
    
    (display "Stream searching tests passed!\n")))

;; ============= ADVANCED STREAM TESTS =============

;; Test stream unfold
(define test-stream-unfold
  (lambda ()
    (display "Testing stream unfold...\n")
    
    ;; Generate natural numbers using unfold
    (define nats-unfold
      (stream-unfold (lambda (x) x)           ; map function
                     (lambda (x) (> x 10))    ; stop condition
                     (lambda (x) (+ x 1))     ; successor
                     0))                      ; seed
    
    (define unfold-list (stream->list nats-unfold))
    (assert (equal? unfold-list '(0 1 2 3 4 5 6 7 8 9 10)) "Unfold natural numbers")
    
    ;; Generate powers of 2 using unfold
    (define powers-unfold
      (stream-unfold (lambda (x) x)
                     (lambda (x) (> x 1000))
                     (lambda (x) (* x 2))
                     1))
    
    (define powers-list (stream->list powers-unfold))
    (assert (equal? powers-list '(1 2 4 8 16 32 64 128 256 512 1024)) "Unfold powers of 2")
    
    (display "Stream unfold tests passed!\n")))

;; Test stream zip
(define test-stream-zip
  (lambda ()
    (display "Testing stream zip...\n")
    
    (define stream1 (list->stream '(1 2 3)))
    (define stream2 (list->stream '(a b c)))
    (define stream3 (list->stream '(x y z)))
    
    ;; Two streams
    (define zipped-2 (stream-zip stream1 stream2))
    (define zip-list-2 (stream->list zipped-2))
    (assert (equal? zip-list-2 '((1 a) (2 b) (3 c))) "Zip two streams")
    
    ;; Three streams
    (define zipped-3 (stream-zip stream1 stream2 stream3))
    (define zip-list-3 (stream->list zipped-3))
    (assert (equal? zip-list-3 '((1 a x) (2 b y) (3 c z))) "Zip three streams")
    
    ;; Unequal length streams
    (define short-stream (list->stream '(1 2)))
    (define long-stream (list->stream '(a b c d)))
    (define zipped-unequal (stream-zip short-stream long-stream))
    (define zip-unequal-list (stream->list zipped-unequal))
    (assert (equal? zip-unequal-list '((1 a) (2 b))) "Zip unequal length streams")
    
    (display "Stream zip tests passed!\n")))

;; ============= ERROR HANDLING TESTS =============

;; Test error conditions
(define test-error-handling
  (lambda ()
    (display "Testing error handling...\n")
    
    ;; stream-car on empty stream should error
    (define (test-empty-car)
      (guard (condition (else #t))
        (stream-car stream-null)
        #f))
    (assert (test-empty-car) "stream-car on empty stream should error")
    
    ;; stream-cdr on empty stream should error  
    (define (test-empty-cdr)
      (guard (condition (else #t))
        (stream-cdr stream-null)
        #f))
    (assert (test-empty-cdr) "stream-cdr on empty stream should error")
    
    ;; stream-ref with negative index should error
    (define (test-negative-ref)
      (guard (condition (else #t))
        (stream-ref (list->stream '(1 2 3)) -1)
        #f))
    (assert (test-negative-ref) "stream-ref with negative index should error")
    
    ;; stream-ref beyond end should error
    (define (test-out-of-bounds-ref)
      (guard (condition (else #t))
        (stream-ref (list->stream '(1 2 3)) 10)
        #f))
    (assert (test-out-of-bounds-ref) "stream-ref out of bounds should error")
    
    (display "Error handling tests passed!\n")))

;; ============= PERFORMANCE TESTS =============

;; Test that operations are properly lazy
(define test-performance
  (lambda ()
    (display "Testing performance and laziness...\n")
    
    ;; Create a very long stream that would be expensive to realize fully
    (define long-stream (stream-range 0 1000000))
    
    ;; Taking just a few elements should be fast
    (define first-10 (stream-take 10 long-stream))
    (assert (= (stream-length first-10) 10) "Can take from very long stream efficiently")
    
    ;; Multiple operations should still be lazy
    (define processed
      (stream-take 5
        (stream-filter even?
          (stream-map (lambda (x) (* x x))
            long-stream))))
    
    (define result-list (stream->list processed))
    (assert (equal? result-list '(0 4 16 36 64)) "Lazy operations on long stream")
    
    ;; Infinite stream should work without issues
    (define infinite-evens (stream-filter even? (stream-from 0)))
    (define first-5-evens (stream->list (stream-take 5 infinite-evens)))
    (assert (equal? first-5-evens '(0 2 4 6 8)) "Infinite stream processing")
    
    (display "Performance tests passed!\n")))

;; ============= INTEGRATION TESTS =============

;; Test integration with SRFI-1
(define test-srfi-1-integration
  (lambda ()
    (display "Testing SRFI-1 integration...\n")
    
    (define test-stream (list->stream '(1 2 3 4 5)))
    
    ;; Convert to list and use SRFI-1 operations
    (define stream-list (stream->list test-stream))
    (define filtered (filter odd? stream-list))
    (assert (equal? filtered '(1 3 5)) "SRFI-1 filter on stream-derived list")
    
    ;; Use SRFI-1 to create list, then convert to stream
    (define iota-list (iota 10 1))  ; 1 to 10
    (define iota-stream (list->stream iota-list))
    (assert (= (stream-ref iota-stream 9) 10) "SRFI-1 iota to stream")
    
    (display "SRFI-1 integration tests passed!\n")))

;; ============= TEST RUNNER =============

;; Simple assertion function
(define (assert condition message)
  (unless condition
    (error "Assertion failed:" message)))

;; Main test runner
(define (run-all-tests)
  (display "Starting SRFI-41 (Streams) test suite...\n\n")
  
  (test-stream-predicates)
  (test-stream-car-cdr)
  (test-lazy-evaluation)
  (test-list-conversion)
  (test-stream-arithmetic)
  (test-stream-operations)
  (test-infinite-streams)
  (test-stream-folding)
  (test-stream-searching)
  (test-stream-unfold)
  (test-stream-zip)
  (test-error-handling)
  (test-performance)
  (test-srfi-1-integration)
  
  (display "\n=== All SRFI-41 tests passed! ===\n"))

;; Run the tests
(run-all-tests)