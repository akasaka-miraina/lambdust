# nomパーサーコンビネータ内製化ロードマップ

## Phase 1.1 完了報告 (2025-08-12)

### 完了事項

#### 1. モジュール構造設計 ✅
```
src/parser/combinators/
├── mod.rs              # メインモジュール定義
├── primitive.rs        # 基本パーサープリミティブ  
├── combinator.rs       # コンビネータ実装
├── scheme.rs           # Scheme特化パーサー
├── builder.rs          # 高レベルAPI
├── nom_compat.rs       # nom互換レイヤー (WIP)
└── optimization.rs     # パフォーマンス最適化 (WIP)
```

#### 2. 基本設計仕様 ✅
- **ゼロコピー設計**: `&str`スライスを直接操作
- **span情報**: 詳細エラー情報のための位置追跡
- **モジュラー構造**: 段階的実装・テスト可能
- **型安全性**: Rustの型システムを活用

#### 3. Scheme特化最適化ポイント ✅
- **S式解析**: 括弧、クォート、ドット対の効率的処理
- **アトム分類**: 数値、シンボル、文字列の高速判定  
- **リスト構造**: メモリ効率的なベクター操作
- **コメント処理**: 行・ブロックコメントのスキップ

#### 4. nom互換性戦略 ✅
- **段階的移行**: ハイブリッドモードで既存コードを保護
- **API互換**: 1:1マッピングで移行コストを最小化
- **エラー変換**: nomエラーと内製エラーの相互変換
- **ベンチマーク**: パフォーマンス比較機能

### Phase 1.2 実装計画

#### 優先度: High (2-3週間)
1. **コンパイルエラー修正**
   - `Clone`トレイト制約の解決
   - ライフタイム問題の修正
   - 循環参照の解決

2. **基本機能の安定化**
   - primitive.rs の完全実装
   - combinator.rs の基本コンビネータ
   - 最小限のテストスイート

#### 優先度: Medium (4-6週間)  
3. **Scheme特化機能**
   - S式パーサーの完全実装
   - 数値システムの統合
   - エラー回復機能

4. **nom互換レイヤー**
   - API互換関数の実装
   - 移行支援ツール
   - パフォーマンス比較

#### 優先度: Low (7-10週間)
5. **最適化機能**
   - SIMD最適化
   - 並列処理
   - メモ化システム

### 技術仕様

#### パーサープリミティブ
```rust
// 基本型
type Input<'a> = &'a str;
type ParseResult<'a, T> = Result<(Input<'a>, T), ParseError>;

// 基本プリミティブ
fn tag(expected: &str) -> Parser<&str>
fn char(expected: char) -> Parser<char>  
fn satisfy<P>(predicate: P) -> Parser<char>
```

#### Scheme特化型
```rust  
enum SchemeSexp<'a> {
    Atom(SchemeAtom<'a>),
    List(Vec<SchemeSexp<'a>>),
    DottedPair(Box<SchemeSexp<'a>>, Box<SchemeSexp<'a>>),
    Quote(Box<SchemeSexp<'a>>),
    // ...
}

enum SchemeAtom<'a> {
    Symbol(&'a str),
    Integer(i64),
    Float(f64),
    String(&'a str),
    // ...
}
```

#### パフォーマンス目標
- **パース速度**: nomと同等以上 (±5%以内)
- **メモリ使用量**: 30%削減 (ゼロコピー効果)
- **エラー品質**: span情報による詳細診断
- **並列化**: 独立した入力の並列処理

### 現在の制約事項

#### 技術的制約
1. **トレイト制約の複雑さ**: `Clone` + `ParserCombinator`の組み合わせ
2. **ライフタイム管理**: 複雑なネストした構造体での'a
3. **型推論の限界**: impl Traitを使った関数型の制約

#### 設計上の課題
1. **エルゴノミクス vs パフォーマンス**: 使いやすさと速度のトレードオフ
2. **nom互換性の程度**: 完全互換 vs 改良版API
3. **並列化の粒度**: ファイル単位 vs 式単位

### Phase 1.3 移行計画

#### 段階的移行戦略
```rust
// Phase 1: ハイブリッドモード
let hybrid_parser = HybridParser::new(false); // nomを使用
hybrid_parser.parse_expression(input);

// Phase 2: 一部機能を内製に切替
hybrid_parser.set_use_internal(true);
hybrid_parser.parse_basic_atoms(input);

// Phase 3: 完全移行
let internal_parser = InternalParser::new();
internal_parser.parse_full_program(input);
```

#### 互換性検証
- 既存テストスイートでの回帰テスト
- パフォーマンスベンチマークでの比較
- メモリプロファイルでの使用量確認

### 期待される効果

#### 即座の利益
- **依存関係削減**: nomクレートの除去
- **カスタム最適化**: Scheme特化の高速化
- **エラー改善**: 詳細な診断情報

#### 長期的利益  
- **保守性向上**: 完全な制御とカスタマイズ
- **機能拡張**: 新機能の迅速な追加
- **パフォーマンス**: 継続的な最適化機会

### 次期Phase計画

#### Phase 2.0: 高度な機能 (3-6ヶ月)
- マクロシステムとの統合
- 型推論システムとの連携  
- ストリーミングパーサー
- 増分解析機能

#### Phase 3.0: 最終最適化 (6-9ヶ月)
- ハードウェア特化最適化
- GPU並列処理
- ネットワーク分散パース
- リアルタイム解析

### リスク評価

#### 高リスク
- **開発期間の延長**: 複雑なトレイト制約による
- **パフォーマンス劣化**: 最適化不足による

#### 中リスク  
- **互換性問題**: nom依存コードとの不整合
- **メモリリーク**: 複雑なライフタイム管理

#### 低リスク
- **機能不足**: 段階的実装で対応可能
- **バグ混入**: 包括的テストで検出可能

## 結論

Phase 1.1では nomパーサーコンビネータの内製化に向けた**基盤設計**を完了しました。モジュール構造、基本仕様、最適化戦略、移行計画を確立し、実装の土台を構築しました。

次のPhase 1.2では、コンパイルエラーの修正と基本機能の安定化に集中し、実用的な内製パーサーコンビネータシステムの実現を目指します。

**重要な成果**: Scheme言語処理に特化した最適化設計により、nomの汎用性を犠牲にしつつも、Lambdustに必要な機能に集中した高性能システムの基盤を確立しました。