# Lambdustへの貢献

Lambdust高品質Schemeインタープリタープロジェクトへの貢献に興味を持っていただき、ありがとうございます！このドキュメントでは、貢献のための包括的なガイドラインを提供します。

## 行動規範

すべての貢献者に対して、歓迎的で包括的な環境を提供することをお約束します。すべてのやり取りにおいて敬意を持ち、建設的であることをお願いします。

## はじめに

### 前提条件

1. **ドキュメントを読む**: 以下のドキュメントを通してプロジェクトに慣れ親しんでください：
   - [README.md](README.md) - プロジェクト概要と機能
   - [ARCHITECTURE.md](ARCHITECTURE.md) - システムアーキテクチャと設計
   - [BUILDING.md](BUILDING.md) - 開発環境とワークフロー

2. **開発環境**: [構築ガイド](BUILDING.md)に従って開発環境を設定してください

3. **品質基準の理解**: Lambdustは、226+構造の100%成功率での構造リファクタリングを通じて確立された厳格な基準により、卓越した品質を維持しています。

## 品質基準

### 必須品質要件

すべての貢献は、以下の交渉不可能な基準を満たす必要があります：

#### コンパイル基準
```bash
# 開発段階（すべての変更に必須）
cargo check --lib                    # 0エラーを返す必要があります

# コミット段階（すべてのコミット前に必須）  
cargo clippy --lib                   # 0エラーかつ0警告を返す必要があります
cargo test                           # すべてのテストが通る必要があります
cargo fmt                            # 適用される必要があります
```

#### 増分開発プロトコル

**重要**: 主要リファクタリングで100%の成功を達成した実証済みの増分開発手法に従ってください：

1. **1回に1つの焦点を絞った変更**: 一度に正確に1つの論理変更を行う
2. **即座の検証**: 各変更後に`cargo check --lib`を実行
3. **ゼロエラー耐性**: 次に進む前に即座にエラーを修正  
4. **品質ゲートの強制**: コミット前にゼロ警告を確認

### コード組織基準

#### 1ファイル1構造ルール
すべてのコードは「1つのファイルにつき1つの主要構造」原則に従う必要があります：

```rust
// ✅ 正しい例: single_structure.rs
pub struct MyStructure {
    field: String,
}

impl MyStructure {
    // 実装はここ
}

// ❌ 間違った例: multiple_structures.rs  
pub struct FirstStructure { ... }
pub struct SecondStructure { ... }  // 複数構造は許可されません
```

#### モジュール組織
- 各モジュールは単一の明確な責任を持つべきです
- `mod.rs`は再エクスポートとモジュール調整のみに使用
- 構造定義は専用ファイルに保持
- 依存関係の境界を明確に維持

### ドキュメント基準

すべてのパブリックインターフェースには包括的なドキュメントが必要です：

```rust
/// 構造の目的と使用方法の包括的な説明。
///
/// # 例
/// 
/// ```rust
/// let example = MyStructure::new("例");
/// assert_eq!(example.field(), "例");
/// ```
pub struct MyStructure {
    /// フィールドの目的と制約を説明するフィールドドキュメント
    field: String,
}

impl MyStructure {
    /// 指定された値で新しいインスタンスを作成します。
    ///
    /// # 引数
    /// * `value` - フィールドの初期値
    ///
    /// # 戻り値
    /// 新しい`MyStructure`インスタンス
    pub fn new(value: impl Into<String>) -> Self {
        Self { field: value.into() }
    }
}
```

## 貢献ワークフロー

### 1. 議論

作業を開始する前に：
- 類似の作業について既存のissueを確認
- 新機能や重要な変更についてはissueを作成
- メンテナーからアプローチとフィードバックを得る

### 2. 開発プロセス

#### ブランチ管理
```bash
# 機能ブランチを作成
git checkout -b feature/descriptive-name

# またはバグ修正の場合
git checkout -b fix/bug-description
```

#### 増分開発
```bash
# 1つの焦点を絞った変更を行う
# 即座の検証を実行
cargo check --lib    # 0エラーである必要があります

# チェックがパスした場合のみ次の変更を続行
# 各論理変更について繰り返す
```

#### コミット前
```bash
# 包括的品質チェック
cargo clippy --lib    # 0エラー、0警告である必要があります  
cargo test            # すべてのテストが通る必要があります
cargo fmt             # フォーマットを適用
```

### 3. コミットガイドライン

#### コミットメッセージ形式
```
type(scope): 簡潔な説明

必要に応じてより長い説明で、何をなぜ変更したかに焦点を当てる。

- 破壊的変更をリストアップ
- 関連するissueを参照
```

#### コミット種類
- `feat`: 新機能
- `fix`: バグ修正  
- `docs`: ドキュメント変更
- `style`: フォーマット、ロジック変更なし
- `refactor`: コードリファクタリング
- `test`: テストの追加や修正
- `perf`: パフォーマンス改善

#### コミット例
```bash
feat(eval): モナディック計算評価を追加

ドメイン、アプリケーション、インフラ層の明確な分離を持つ
モナディック評価アーキテクチャを実装します。

- 合成可能な計算のためのMonadicComputationトレイトを追加
- 計算協調のための評価オーケストレーターを実装
- エフェクトインタープリター統合を提供

Closes #123

fix(concurrency): エフェクト協調におけるスレッドセーフティを解決

共有エフェクト状態へのアクセスを適切に同期することで、
並行エフェクト処理における競合状態を修正します。

- スレッドセーフティのためEffectCoordinatorでArc<RwLock<T>>を使用
- 並行シナリオの包括的テストカバレッジを追加
- 既存のAPIとの後方互換性を維持

Fixes #456
```

### 4. プルリクエストプロセス

#### PRタイトルと説明
```markdown
# プルリクエストタイトル
コミットメッセージ規約に従った簡潔で説明的なタイトル

## 概要
このPRが達成することの明確な説明

## 変更点
- 行われた具体的な変更のリスト
- 追加された新機能や能力
- 実装されたバグ修正や改善

## テスト
- 変更がどのようにテストされたか
- 追加された新しいテスト
- 関連する場合のパフォーマンス影響分析

## ドキュメント
- 含まれているドキュメント更新
- 文書化されたAPI変更
- 必要に応じて更新された例

## 品質チェックリスト
- [ ] `cargo check --lib`が0エラーを返す
- [ ] `cargo clippy --lib`が0エラー・0警告を返す
- [ ] `cargo test`がすべてのテストを通過
- [ ] コードが1ファイル1構造原則に従っている
- [ ] すべてのパブリックAPIが文書化されている
- [ ] アーキテクチャ原則が維持されている
```

#### レビュープロセス
1. **自動チェック**: すべてのCIチェックが通る必要があります
2. **コードレビュー**: 少なくとも1人のメンテナーレビューが必要
3. **品質検証**: 品質基準の手動検証
4. **統合テスト**: 統合環境での包括的テスト

## 貢献の種類

### コード貢献

#### 言語機能
- R7RS-large準拠の改善
- 型システムの拡張  
- エフェクトシステムの拡張
- マクロシステムの改善

#### パフォーマンス改善
- 最適化実装
- ベンチマーク強化
- メモリ管理改善
- 並行評価最適化

#### インフラ
- ビルドシステム改善
- テストインフラ
- 開発ツール
- CI/CDパイプライン強化

### ドキュメント貢献

#### API ドキュメント
- 関数・メソッドドキュメント
- 使用例とチュートリアル
- アーキテクチャ説明
- パフォーマンスガイド

#### ユーザードキュメント
- はじめにガイド
- 機能説明
- ベストプラクティスドキュメント
- 移行ガイド

### テスト貢献

#### テストカバレッジ
- 新機能の単体テスト
- システム相互作用の統合テスト
- 重要アルゴリズムのプロパティベーステスト
- パフォーマンス回帰テスト

#### 品質保証
- コードレビューとフィードバック
- バグ報告と検証
- パフォーマンス分析と最適化
- セキュリティ分析と改善

## アーキテクチャガイドライン

### 設計原則

1. **クリーンアーキテクチャ**: ドメイン、アプリケーション、インフラ層間の明確な分離を維持
2. **単一責任**: 各モジュールは1つの明確な目的を持つべき
3. **依存性逆転**: 具象実装ではなく抽象に依存
4. **合成優先**: 複雑な継承階層より合成とトレイトを優先

### モジュール設計

```rust
// ✅ 良い例: 明確で焦点を絞ったモジュール
pub mod evaluation_orchestrator {
    /// モナディック評価ワークフローを協調
    pub struct EvaluationOrchestrator {
        // 単一責任: 協調
    }
}

// ❌ 避けるべき例: 混在した責任
pub mod evaluation_system {
    pub struct Evaluator { ... }         // 評価ロジック
    pub struct Parser { ... }            // パースロジック - 分離すべき
    pub struct TypeChecker { ... }       // 型チェック - 分離すべき
}
```

### エラーハンドリング

確立された診断エラーシステムを使用：

```rust
use crate::diagnostics::{Result, Error};

pub fn example_function() -> Result<Value> {
    // 一貫したエラーハンドリングのためエラーヘルパーを使用
    match computation {
        Ok(result) => Ok(result),
        Err(_) => Err(Error::runtime_error("明確なエラーメッセージ", span).boxed()),
    }
}
```

## テストガイドライン

### テスト組織

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_specific_functionality() {
        // 準備
        let input = create_test_input();
        
        // 実行  
        let result = function_under_test(input);
        
        // 検証
        assert_eq!(result, expected_output);
    }

    #[test]
    fn test_error_conditions() {
        // エラーシナリオをテスト
        let result = function_with_invalid_input();
        assert!(result.is_err());
    }
}
```

### 統合テスト

```rust
// tests/integration_example.rs
use lambdust::prelude::*;

#[test]
fn test_end_to_end_evaluation() {
    let interpreter = Interpreter::new();
    let result = interpreter.eval("(+ 1 2 3)").unwrap();
    assert_eq!(result, Value::number(6.0));
}
```

## パフォーマンスガイドライン

### ベンチマーク

パフォーマンス関連の変更には統合ベンチマークシステムを使用：

```rust
use criterion::{criterion_group, criterion_main, Criterion};

fn benchmark_evaluation(c: &mut Criterion) {
    c.bench_function("fibonacci_30", |b| {
        b.iter(|| fibonacci(30))
    });
}

criterion_group!(benches, benchmark_evaluation);
criterion_main!(benches);
```

### メモリ管理

- Rustの所有権原則に従う
- 共有可変状態には`Arc<RwLock<T>>`を使用
- 単一スレッドシナリオでは`Rc<RefCell<T>>`を優先
- 頻繁な割り当てにはメモリプールを考慮

## リリースプロセス

### バージョン管理

セマンティックバージョニング（SemVer）に従います：
- **メジャー**: 破壊的なAPI変更
- **マイナー**: 新機能、後方互換
- **パッチ**: バグ修正、後方互換

### リリースチェックリスト

1. **品質検証**
   - [ ] すべてのテストが通過
   - [ ] Clippy警告ゼロ
   - [ ] 包括的ドキュメントレビュー
   - [ ] パフォーマンス回帰テスト

2. **ドキュメント更新**
   - [ ] CHANGELOG.md更新
   - [ ] APIドキュメント最新
   - [ ] README.md新機能反映
   - [ ] 必要に応じて移行ガイド

3. **リリース準備**
   - [ ] バージョン番号更新
   - [ ] Gitタグ作成
   - [ ] リリースノート準備
   - [ ] Crates.io公開準備

## 認識

貢献者は以下を通じて認識されます：
- README.mdの貢献者リスト
- リリースノートでの謝辞  
- GitHubの貢献者統計
- 重要な貢献に対するオプションのブログ投稿

## ヘルプを得る

### コミュニケーションチャネル

- **GitHub Issues**: バグ報告、機能要求
- **GitHub Discussions**: 一般的質問、アイデア
- **コードレビュー**: プルリクエストでのフィードバック

### リソース

- [アーキテクチャドキュメント](ARCHITECTURE.md)
- [APIリファレンス](../API_REFERENCE.md)
- [パフォーマンスガイド](../PERFORMANCE.md)
- [型システムガイド](../TYPE_SYSTEM.md)
- [エフェクトシステムガイド](../EFFECT_SYSTEM.md)

## ありがとうございます

あなたの貢献は、Lambdustを世界クラスのScheme実装にするのに役立ちます。コード、ドキュメント、テスト、フィードバックを問わず、すべての貢献は価値があり、感謝されています。

Lambdustコミュニティへようこそ！