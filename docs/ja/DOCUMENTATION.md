# Lambdust ドキュメント

## 目次

1. [概要](#概要)
2. [アーキテクチャ](#アーキテクチャ)
3. [ビルドとインストール](#ビルドとインストール)
4. [API リファレンス](#api-リファレンス)
5. [型システム](#型システム)
6. [エフェクトシステム](#エフェクトシステム)
7. [並行性](#並行性)
8. [パフォーマンス](#パフォーマンス)
9. [コントリビューション](#コントリビューション)
10. [変更履歴](#変更履歴)

## 概要

LambdustはRustで書かれた包括的なR7RS-large準拠のSchemeインタープリターで、高度な型システム、エフェクト処理、並行性プリミティブ、パフォーマンス最適化機能を備えています。

### 主な機能

- **R7RS-large準拠**: SRFI実装を含むR7RS-large Scheme標準の広範なサポート
- **高度な型システム**: 漸進的型付け、代数データ型、型クラス
- **エフェクトシステム**: 副作用管理のためのエフェクトハンドラーを持つモナディックプログラミング
- **並行システム**: アクターモデル、Future、STM（ソフトウェアトランザクショナルメモリ）、並列計算
- **FFIシステム**: 動的ライブラリ読み込みを含むC言語相互運用性
- **メタプログラミング**: 衛生的マクロ、リフレクション、コード生成
- **パフォーマンス最適化**: バイトコードコンパイルとプリミティブ特殊化

### コアコンポーネント

Lambdustは42個のコアプリミティブを中心に構築されており、これらがシステム全体をブートストラップし、Rustの所有権システムによるメモリ安全性を維持しながらScheme言語機能の堅固な基盤を提供します。

## アーキテクチャ

### システムアーキテクチャ

インタープリターは相互接続された複数のサブシステムで構成されています：

- **パーサー**: Schemeソースコードを抽象構文木（AST）に変換
- **評価器**: コアプリミティブ操作を使用してScheme式を実行
- **型システム**: 推論とチェックを含む漸進的型付けを提供
- **エフェクトシステム**: モナディック合成による副作用の管理
- **ランタイム**: 全サブシステムを調整し実行環境を提供
- **メモリ管理**: Schemeの値に対するガベージコレクション付きRustベース所有権

### 値システム

すべてのSchemeの値は統一された`Value`列挙型で表現され、以下をサポートします：
- 基本型: 数値、文字列、シンボル、文字
- 複合型: ペア、ベクタ、手続き
- 高度な型: 代数データ型、型クラス
- 特殊値: 継続、ポート、promise

### 環境システム

変数束縛とスコープ管理は以下を通じて処理されます：
- 適切な末尾再帰を伴う語彙スコープ
- 特殊形式用の動的環境サポート
- インポート/エクスポート機能を持つモジュールシステム

## ビルドとインストール

### 前提条件

- Rust 1.75.0以降
- Cargoパッケージマネージャー
- プラットフォーム固有の開発ツール（FFI用）

### ビルドコマンド

```bash
# 基本ビルド
cargo build

# 最適化付きリリースビルド
cargo build --release

# テスト実行
cargo test

# 特定の機能付きビルド
cargo build --features "enhanced-repl,async-runtime"

# パフォーマンス監視
cargo run --bin performance-monitor
```

### 機能フラグ

ビルドをカスタマイズするための利用可能な機能フラグ：

- `minimal-repl`: 基本機能を持つ軽量REPL
- `enhanced-repl`: 構文ハイライト付き高機能REPL
- `async-runtime`: 非同期ランタイムサポート
- `network-io`: ネットワークI/O機能
- `ffi`: 外部関数インターフェースサポート
- `benchmarks`: パフォーマンスベンチマークツール

## API リファレンス

### コアプリミティブ

42個のコアプリミティブがすべてのScheme操作の基盤を形成します：

#### 算術演算
- `+`, `-`, `*`, `/`: 基本算術
- `=`, `<`, `>`, `<=`, `>=`: 数値比較
- `number?`, `integer?`, `real?`: 型述語

#### リスト操作
- `cons`, `car`, `cdr`: 基本ペア操作
- `list`, `length`, `append`: リスト操作
- `null?`, `pair?`: リスト述語

#### 制御フロー
- `if`, `cond`, `case`: 条件式
- `and`, `or`, `not`: ブール演算
- `call/cc`: 継続

#### I/O操作
- `read`, `write`, `display`: 入出力
- `open-input-port`, `close-port`: ポート管理

### 高度な機能

#### 型システム統合

```scheme
;; 漸進的型付けの例
(define (factorial (n : Integer)) : Integer
  (if (<= n 1)
      1
      (* n (factorial (- n 1)))))
```

#### エフェクトシステム使用

```scheme
;; エフェクト処理
(with-effects
  (IO State)
  (do-io-operation)
  (modify-state value))
```

## 型システム

### 漸進的型付け

Lambdustは漸進的型付けをサポートし、動的型付けと静的型付けの間でスムーズに移行できます：

- **動的型付け**: ランタイム型チェックを持つ従来のScheme動作
- **静的型付け**: 型注釈によるコンパイル時型検証
- **混合モード**: 型付きコードと型なしコードのシームレスな組み合わせ

### 型クラス

Haskellスタイルの型クラスをサポートし、ジェネリックプログラミングが可能：

```scheme
(define-type-class Eq a
  (== : a -> a -> Boolean))

(define-instance (Eq Integer)
  (== = integer-equal?))
```

### 代数データ型

パターンマッチングを伴うカスタムデータ型の定義：

```scheme
(define-data Maybe a
  Nothing
  (Just a))

(define (maybe-map f m)
  (match m
    (Nothing Nothing)
    ((Just x) (Just (f x)))))
```

## エフェクトシステム

### モナディックアーキテクチャ

エフェクトシステムはモナディック原理に基づいて構築され、副作用の純粋関数的管理を可能にします：

- **IOエフェクト**: ファイルシステム、ネットワーク、コンソール操作
- **Stateエフェクト**: 可変状態管理
- **Errorエフェクト**: 例外処理とエラー伝播
- **Asyncエフェクト**: 非同期計算の調整

### エフェクトハンドラー

ドメイン固有のエフェクト管理のためのカスタムエフェクトハンドラーを定義可能：

```scheme
(define-effect Logger
  (log-info : String -> Unit)
  (log-error : String -> Unit))

(define console-logger
  (handler Logger
    (log-info msg (display msg))
    (log-error msg (display msg stderr))))
```

## 並行性

### アクターシステム

Lambdustはアクターベースの並行性モデルを提供：

- **アクター**: プライベート状態を持つ分離された計算単位
- **メッセージパッシング**: アクター間の非同期通信
- **スーパービジョン**: 階層的エラー処理と回復

### FutureとPromise

Futureを通じた非同期計算サポート：

```scheme
(define future-result
  (future (expensive-computation)))

(define combined
  (await (map-future process-result future-result)))
```

### ソフトウェアトランザクショナルメモリ（STM）

STMによるロックフリー並行性：

```scheme
(define account-balance (stm-var 1000))

(stm-atomic
  (lambda ()
    (let ((balance (stm-read account-balance)))
      (stm-write account-balance (- balance 100)))))
```

## パフォーマンス

### 最適化機能

- **バイトコードコンパイル**: 頻繁に実行されるコード用のJITコンパイル
- **プリミティブ特殊化**: 型固有の最適化
- **SIMD操作**: ベクトル化された数値計算
- **メモリプール**: アロケーションオーバーヘッドの削減

### ベンチマーク

専用のパフォーマンスモニターによりパフォーマンス監視が利用可能：

```bash
cargo run --bin performance-monitor --features benchmarks
```

### メモリ管理

- **ゼロコピー操作**: 可能な限りメモリアロケーションを最小化
- **参照カウント**: Scheme値の自動メモリ管理
- **メモリ安全性**: Rustの所有権システムがメモリリークと安全でないアクセスを防止

## コントリビューション

### 開発ガイドライン

1. **コード品質**: すべてのコードは警告ゼロで`cargo clippy`をパスする必要があります
2. **テスト**: 新機能には包括的なテストカバレッジが必要です
3. **ドキュメント**: すべての公開APIにはドキュメントが必要です
4. **パフォーマンス**: 変更のパフォーマンスへの影響を考慮してください

### 開発ワークフロー

1. mainからフィーチャーブランチを作成
2. テスト付きで変更を実装
3. すべてのテストがパスすることを確認: `cargo test`
4. コード品質をチェック: `cargo clippy`
5. 詳細な説明付きでプルリクエストを提出

### コード組織化

- 1ファイル1構造体
- 構造体名とファイル名の一致
- `mod.rs`ファイルに構造体を定義しない
- 関心の明確な分離

## 変更履歴

### バージョン 0.1.1（現在）

#### 機能
- 完全なR7RS-large準拠実装
- 漸進的型付けを持つ高度な型システム
- モナディックアーキテクチャを持つエフェクトシステム
- 並行性プリミティブ（アクター、Future、STM）
- C言語相互運用性用FFIシステム
- パフォーマンス監視とベンチマークツール

#### 改善
- 外部依存関係を内部実装に置き換え
- 包括的なテストスイートと品質保証
- メモリ使用量とアロケーションパターンの最適化
- エラー報告と診断の拡張

#### バグ修正
- すべてのコンパイル警告とエラーを解決
- FFIレイヤーのメモリ安全性問題を修正
- 型推論のエッジケースを修正

### 今後のリリース

#### バージョン 0.1.2（予定）
- ドキュメントと例の拡張
- パフォーマンス最適化とSIMD改善
- SRFIライブラリ実装の拡張
- IDE統合サポート

#### バージョン 0.2.0（ロードマップ）
- JITコンパイルの改善
- 高度なデバッグツール
- クロスプラットフォームバイナリ配布
- コミュニティコントリビューションガイドライン