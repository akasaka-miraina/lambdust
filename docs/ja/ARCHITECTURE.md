# Lambdust アーキテクチャドキュメント

このドキュメントでは、体系的な構造リファクタリングによって達成されたクリーンなモジュラー設計に焦点を当て、Lambdust処理系のアーキテクチャの包括的概要を提供します。

## 目次

1. [概要](#概要)
2. [コアアーキテクチャ原則](#コアアーキテクチャ原則)
3. [システムコンポーネント](#システムコンポーネント)
4. [モジュール組織](#モジュール組織)
5. [データフロー](#データフロー)
6. [主要な設計決定](#主要な設計決定)
7. [パフォーマンス考慮事項](#パフォーマンス考慮事項)

## 概要

Lambdustは以下を成功に組み合わせるモダンでモジュラーなScheme処理系として設計されています：

- **関心の明確な分離** 226+の個別に構造化されたモジュール
- **段階的型付け統合** 動的・静的型システムの架橋
- **エフェクトシステム協調** 計算文脈の透過的管理
- **高性能ランタイム** バイトコードコンパイルと並列評価

アーキテクチャは以下を達成するために体系的にリファクタリングされました：
- ✅ **ゼロコンパイルエラー** 開発全体を通じて維持
- ✅ **ゼロclippyワーニング** コード品質標準を確保
- ✅ **プロフェッショナルなドキュメント** すべてのパブリックインターフェース
- ✅ **one-structure-per-fileの原則** 最大限のモジュール化

## コアアーキテクチャ原則

### 1. **モジュラー設計**
- 重要な構造体はすべて専用ファイルに配置
- 包括的なドキュメント付きの明確なパブリックAPI境界
- 明確に定義されたインターフェースによるコンポーネント間の最小カップリング

### 2. **インクリメンタル品質**
- 開発中の継続的コンパイル確認
- 開発ステップごとに品質ゲートを実施
- 即座のフィードバックループによるエラーフリー開発

### 3. **関数型アーキテクチャ**
- `im`クレートを使用した可能な限りの不変データ構造
- 透過的なエフェクト処理による純関数型評価
- 参照透過性を保持するモナディックエフェクト管理

### 4. **パフォーマンス第一の設計**
- 実現可能な場所でのゼロコピー操作
- 割り当て重い操作のためのメモリプーリング
- 数値計算のSIMD最適化
- 頻繁に実行されるコードのバイトコードコンパイル

## システムコンポーネント

アーキテクチャは8つの主要サブシステムに組織されています：

### 1. 🎯 **コア実装** (`src/`)

#### **字句解析** (`src/lexer/`)
- `lexer.rs` - `logos`クレートを使用したメイントークン化エンジン
- `token.rs` - トークン定義とトークンストリーム管理
- `numeric.rs` - 特殊化された数値リテラル解析
- `optimized.rs` - パフォーマンス最適化されたトークン化パス
- `string_utils.rs` - 文字列処理ユーティリティ

#### **構文解析** (`src/parser/`)
- `parser.rs` - メイン再帰下降パーサー
- `expression.rs` - 優先順位処理付き式解析
- `literals.rs` - リテラル値解析（数値、文字列、シンボル）
- `special_forms.rs` - 特殊形式の認識と解析
- `parser_builder.rs` - 設定可能なパーサー構築

### 2. 🏗️ **言語システム**

#### **型システム** (`src/types/`)
- `type_checker.rs` - 4段階段階的型チェック
- `inference.rs` - Hindley-Milner型推論エンジン
- `unification.rs` - occurs checkつき型統一
- `type_classes.rs` - 制約解決つき型クラスシステム
- `algebraic.rs` - 代数的データ型とパターンマッチング
- `gradual.rs` - 動的・静的型統合
- `integration_bridge.rs` - 型システム間のブリッジ

#### **エフェクトシステム** (`src/effects/`)
- `effect_system.rs` - 中央エフェクト協調
- `effect_context.rs` - 計算文脈追跡
- `handler.rs` - エフェクトハンドラー実装
- `monad.rs` - コアモナディック抽象化
- `lifting.rs` - 自動エフェクトリフティングルール
- `generational.rs` - 世代環境管理

### 3. ⚡ **ランタイムとパフォーマンス**

#### **ランタイム協調** (`src/runtime/`)
- `lambdust_runtime.rs` - マルチスレッドランタイム協調
- `effect_coordinator.rs` - エフェクトシステム統合
- `bootstrap.rs` - システム初期化とプリミティブローディング
- `evaluator.rs` - ランタイム評価器インターフェース
- `thread_pool.rs` - 並列評価のためのスレッドプール管理

## モジュール組織

### ファイル構造の原則

すべてのモジュールは**one-structure-per-file**の原則に従います：

```rust
// ✅ 正しい: src/effects/effect_context.rs
pub struct EffectContext {
    // ファイルごとに単一の主構造体
}

impl EffectContext {
    // すべての実装は同じファイル内
}

// ✅ 正しい: src/effects/mod.rs  
pub mod effect_context;
pub mod effect_system;

pub use effect_context::EffectContext;
pub use effect_system::EffectSystem;

// ヘルパー関数はmod.rsで許可
pub fn helper_function() -> bool {
    true
}
```

### ドキュメント標準

すべてのパブリックインターフェースは包括的なドキュメントを含みます：

```rust
/// 計算文脈とエフェクトを追跡するためのエフェクト文脈。
///
/// この構造体は評価中の現在の計算文脈を維持し、
/// アクティブなエフェクトを追跡し、エフェクト処理と
/// モナディックリフティングの基盤を提供します。
///
/// # 例
///
/// ```rust
/// let mut context = EffectContext::new();
/// context.push_effect(Effect::IO);
/// assert!(context.has_effect(&Effect::IO));
/// ```
pub struct EffectContext {
    // ...
}
```

## データフロー

### 1. **コンパイルパイプライン**

```
ソースコード
    ↓
字句解析器（トークン化）
    ↓
構文解析器（AST生成）
    ↓
マクロ展開器（衛生性）
    ↓
型チェッカー（推論）
    ↓
エフェクト解析器（追跡）
    ↓
バイトコードコンパイラ（最適化）
    ↓
仮想マシン（実行）
```

### 2. **エフェクト統合**

```
純粋計算
    ↓
エフェクト検出
    ↓
エフェクト文脈更新
    ↓
ハンドラー解決
    ↓
モナディックリフティング
    ↓
エフェクトフル計算
```

## 主要な設計決定

### 1. **統一値表現**

`src/eval/value.rs`の`Value`列挙型が、すべてのScheme値の真の情報源として機能：

```rust
pub enum Value {
    // 基本型
    Number(Number),
    String(String), 
    Symbol(Symbol),
    Boolean(bool),
    Char(char),
    
    // 複合型
    Pair(Box<Value>, Box<Value>),
    Vector(Vec<Value>),
    
    // 関数と制御
    Procedure(Procedure),
    Continuation(Continuation),
    
    // 高度な機能
    TypeValue(TypeValue),
    ForeignObject(ForeignObject),
    // ...
}
```

**根拠**: 単一表現により、パフォーマンスを維持しながら型チェック、エフェクト追跡、FFI統合が簡素化されます。

### 2. **42コアプリミティブ**

システムは基本的なすべての操作を実装する正確に42のコアプリミティブでブートストラップされます：

```rust
// コアプリミティブ操作
fn primitive_add(args: &[Value]) -> Result<Value>;
fn primitive_apply(args: &[Value]) -> Result<Value>;
fn primitive_car(args: &[Value]) -> Result<Value>;
// ... さらに39のプリミティブ
```

**根拠**: 最小カーネルアプローチにより、拡張性を最大化しながら正確性について推論できます。

## パフォーマンス考慮事項

### 1. **メモリ管理**

- Scheme値の**参照カウント** `Rc<RefCell<T>>`付き
- 頻繁な割り当て用の**メモリプール**（`src/utils/memory_pool.rs`）
- シンボル用の**文字列インターニング**（`src/utils/string_interner.rs`）

### 2. **最適化戦略**

- 一般的操作の**高速パス実行**（`src/eval/fast_path.rs`）
- 型情報に基づく**プリミティブ特殊化**
- マルチパス最適化付き**バイトコードコンパイル**
- 数値配列の**SIMDベクタ化**

### 3. **並行性設計**

- 可能な場所での**ロックフリーデータ構造**
- 並列評価のための**ワークスティーリングスケジューラー**
- 高レベル並行性のための**アクターモデル**
- 協調更新のための**STM（ソフトウェアトランザクショナルメモリ）**

---

このアーキテクチャは、システムの整合性とパフォーマンス特性を保持しながら、100%の成功率で構造移行を実現した体系的なリファクタリング努力の集大成を表します。モジュラー設計により、継続的な進化を可能にしています。